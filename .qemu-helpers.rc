#!/bin/bash

# qemu alias
#alias qemu='qemu-system-x86_64 -accel kvm -machine q35 -m 2048 -cpu Nehalem,kvm=off -smp 2 -device qemu-xhci -device usb-tablet -parallel null -serial mon:stdio'

# qemu command line helper (function)
#  use configuration file if exists AND executable
#  otherwise call qemu with defined/prefered parameters
#  additional parameters (override) are forwarded in both cases
#  (use #!/usr/bin/false as shebang in configuration file to avoid execution)
qemu() {
	local config=qemu.cfg config_args
	local qemu=qemu-system-x86_64

	# In bash/ksh/zsh you should always use [[ and never [
	# and within [[ certain variables are always expanded as if quoted
	if [[ -s $config ]] && [[ -x $config ]]; then
		# Quote EVERY EXPANSION, **especially** when it's $@!
		# I suspect you are relying on grep returning multiple words
		# and that is why your subshell was left unquoted here. I have
		# replaced this unsafe construct with a safe equivalent.
		mapfile -t config_args < <(grep -v '#.*' "$config" | grep -vE '^[[:space:]]*$' | tr ' ' '\n')
		TMPDIR=/tmp/ "$qemu" "${config_args[@]}" "$@"

		# unrelatedly, did you intend grep to exclude lines with trailing
		# line comments? Perhaps you intended to say something like:
		#	grep -Ev '^[[:space:]]*#'
		# to drop only commented-out lines?
	else
		# again, quote your expansions! *Especially* $@
		TMPDIR=/tmp/ "$qemu" \
		-accel kvm \
		-machine q35 -m 2048 \
		-cpu Nehalem,kvm=off -smp 2 \
		-device qemu-xhci -device usb-tablet \
		-parallel null -serial mon:stdio \
		"$@"
	fi
}

# qemu-img create helper (bash function)
#  no need to specify backing file format (auto-detected)
#  and/or desired file format (qcow2 by default)
# qemu-img tree helper (bash function)
#  display dependencies (base images) in tree form
qemu-img () {
	local bin=/usr/bin/qemu-img
	local verb=$1
	shift
	local base baseFormat format

	# again preferring [[ to [ and quoting only when necessary
	if [[ $verb == create ]]; then
		local opt OPTARG OPTIND
		while getopts 'b:F:f:' opt
		do
			case $opt in
				b) base=$OPTARG;;
				F) baseFormat=$OPTARG;;
				f) format=$OPTARG;;
			esac
		done
		# quote every expansion
		shift "$((OPTIND-1))"

		# again prefer [[ to [, but also stop relying on [ $var ] to
		# check for an empty string. That's what -n is for. The fact
		# that [[ "$var" ]] works is due to a (reliable) quirk, not
		# because it's an intended feature.
		[[ -n $format ]] ||
			format='qcow2'
		if [[ -n $base ]]; then
			# why redirect to /dev/stderr instead of 2?
			[[ ! -e $base ]] &&
				echo 'Base image: no such file or directory' >/dev/stderr &&
					return 1
			[[ ! -r $base ]] &&
				echo 'Base image: no read permission' >/dev/stderr &&
					return 1
			[[ -w $base ]] &&
				echo 'Base image: base image is writable' >/dev/stderr &&
					return 1
			[[ -n $baseFormat ]] ||
				baseFormat=$(
					[[ "$( head -c4 "$base" | base64 )" == "UUZJ+w==" ]] &&
						echo qcow2 ||
							echo raw
				)
			# quote every expansion! Especially $@
			"$bin" "$verb" -b "$base" -F "$baseFormat" -f "$format" "$@"
		else
			# quote every expansion! Especially $@
			"$bin" "$verb" -f "$format" "$@"
		fi
	elif [[ $verb == tree ]]; then
		local info=$( qemu-img info --force-share --output=json "$1" )
		if [[ -n $info ]]; then
			local virtualSize diskSize fileFormat backingFile
			IFS=$'\n' read -srd '' virtualSize diskSize fileFormat backingFile < <(
				# quote EVERY expansion!
				jq -r '."virtual-size",."actual-size",."format",."full-backing-filename"' <<< "$info"
			)
			IFS=$'\n' read -srd '' virtualSize diskSize < <(
				# quote EVERY expansion!!
				numfmt --to=iec "$virtualSize" "$diskSize"
			)
			[[ -n $2 ]] && [[ -w $1 ]] && tput setaf 3
			# use printf to make output format easier to understand
			# and just because printf is better than echo
			[[ ${fileFormat,,} == raw ]] &&
			printf '%s%s (%s - %s\n' \
				"$2" "$1" "${fileFormat^^}" "$virtualSize" ||
			printf '%s%s (%s - %s / %s)\n' \
				"$2" "$1" "${fileFormat^^}" "$diskSize" "$virtualSize"
			tput sgr0
			[[ $backingFile != null ]] && qemu-img tree "$( readlink -e "$backingFile" )" " ${2:-└─ }"
		fi
	else
		# [ ! "$var" ] instead of [[ -z $var ]] is even worse than not using -n
		# again quoting $@ because yikes
		[[ -z $verb ]] && "$bin" --help || "$bin" "$verb" "$@"
	fi
}

# qemu USB helper (bash function)
qemu-usbhost() {
	# also declaring a local usb variable so it doesn't leak into the outer
	# scope
	local usb busport product vendor

	# do not use for var in $(unquoted subshell); it's always broken!
	while IFS= read -r -d '' usb; do
		# quote every expansion! No exceptions, even if you think it's saf.e
		cat "$usb"/product 2>/dev/null || echo 'unknown device'

		# you can avoid basename using parameter expansion
		busport=${usb##*/}

		# Use of printf should be preferred to echo generally
		# and in this situation makes formatting choices more clear.
		# Quoting the subsell expansion because, again, *always* quote.
		printf ' %s\n' "$(
			sed -e 's/-/,hostport=/' \
				-e 's/^/device_add usb-host,hostbus=/' \
				-e 's/$/,id=usb-host-'"$busport"/ <<< "$busport"
		)"

		# read without -r is broken, always use -r
		# read without setting IFS trims whitespace. Always set IFS to
		# make it clear whether you intended trimming to occur. Again,
		# always quote expansions.
		IFS= read  -r vendor < "$usb"/idVendor
		IFS= read  -r product < "$usb"/idProduct

		# again, formatting choice is more clear with printf, and printf
		# is better than echo anyway.
		printf' device_add usb-host,vendorid=0x%s,productid=0x%s,id=usb-host-%s-%s\n\n' \
			"$vendor" "$product" "$vendor" "$product"
	done < <(
		# no need to pipe to grep, GNU find can match regex directly
		# using NUL delimited output for maximum safety
		find /sys/bus/usb/devices/ \
			-regextype posix-egrep \
			-regex '^/sys/bus/usb/devices/[0-9]+-[0-9]+$' \
			-print0
	) | tr '[:upper:]' '[:lower:]'
}

# vim: set ft=sh :
